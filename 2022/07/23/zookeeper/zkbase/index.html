<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/zhukovaskychina-github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zhukovaskychina-github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zhukovaskychina-github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zhukovaskychina-github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zhukovaskychina-github.io/css/main.css">


<link rel="stylesheet" href="/zhukovaskychina-github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhukovaskychina.github.io","root":"/zhukovaskychina-github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Zookeeper是一个分布式数据一致性的解决方案，分布式应用可以基于它实现诸如数据发布&#x2F;订阅，负载均衡，命名服务，分布式协调&#x2F;通知，集群管理，Master选举， 分布式锁和分布式队列等功能。Zookeeper致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力的分布式协调系统.">
<meta property="og:type" content="article">
<meta property="og:title" content="zk">
<meta property="og:url" content="https://zhukovaskychina.github.io/zhukovaskychina-github.io/2022/07/23/zookeeper/zkbase/index.html">
<meta property="og:site_name" content="zhukovasky的博客">
<meta property="og:description" content="Zookeeper是一个分布式数据一致性的解决方案，分布式应用可以基于它实现诸如数据发布&#x2F;订阅，负载均衡，命名服务，分布式协调&#x2F;通知，集群管理，Master选举， 分布式锁和分布式队列等功能。Zookeeper致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力的分布式协调系统.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk12.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk13.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk15.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk17.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk26.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk28.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk29.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk30.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk31.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk31.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk20.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk21.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk22.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk23.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk24.png">
<meta property="article:published_time" content="2022-07-23T12:57:54.000Z">
<meta property="article:modified_time" content="2022-07-28T08:03:13.446Z">
<meta property="article:author" content="zhukovasky">
<meta property="article:tag" content="zookeeper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk1.png">

<link rel="canonical" href="https://zhukovaskychina.github.io/zhukovaskychina-github.io/2022/07/23/zookeeper/zkbase/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>zk | zhukovasky的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zhukovaskychina-github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhukovasky的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">技术宅的世界</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zhukovaskychina-github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zhukovaskychina-github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">16</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zhukovaskychina" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhukovaskychina.github.io/zhukovaskychina-github.io/2022/07/23/zookeeper/zkbase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zhukovaskychina-github.io/images/avatar.gif">
      <meta itemprop="name" content="zhukovasky">
      <meta itemprop="description" content="技术宅的世界">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhukovasky的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          zk
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-23 20:57:54" itemprop="dateCreated datePublished" datetime="2022-07-23T20:57:54+08:00">2022-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-28 16:03:13" itemprop="dateModified" datetime="2022-07-28T16:03:13+08:00">2022-07-28</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">Zookeeper是一个分布式数据一致性的解决方案，分布式应用可以基于它实现诸如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master选举， 分布式锁和分布式队列等功能。Zookeeper致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力的分布式协调系统.</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="zookeeper概要"><a href="#zookeeper概要" class="headerlink" title="zookeeper概要"></a><strong>zookeeper概要</strong></h3><p>Zookeeper是一个分布式数据一致性的解决方案，分布式应用可以基于它实现诸如数据发布&#x2F;订阅，负载均衡，命名服务，分布式协调&#x2F;通知，集群管理，Master选举，<br>分布式锁和分布式队列等功能。Zookeeper致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力的分布式协调系统.</p>
<p>ZooKeeper是用于分布式应用程序的协调服务。它公开了一组简单的API，<br>分布式应用程序可以基于这些API用于同步，节点状态、配置等信息、服务注册等信息。其由JAVA编写，支持JAVA 和C两种语言的客户端。<br><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk1.png" alt="图片"></p>
<h3 id="zookeeper产生背景"><a href="#zookeeper产生背景" class="headerlink" title="zookeeper产生背景"></a><strong>zookeeper产生背景</strong></h3><p>随着互联网时代的发展项目已经从单点项目到现在的分布式项目，部署在多个服务器上随着而来产生多个节点之间的协同问题</p>
<pre><code>1. 各个项目之间的RPC调用如何进行服务发现
2. 如何保证任务在那个节点执行
3. 如何保证并发请求的幂等
4. 如何保证容错...
</code></pre>
<p>这些问题可以统一归纳为多节点协调问题，如果靠节点自身进行协调这是非常不可靠的，性能上也不可取。<br>必须由一个独立的服务做协调工作，它必须可靠，而且保证性能。</p>
<h3 id="zookeeper的作用"><a href="#zookeeper的作用" class="headerlink" title="zookeeper的作用"></a><strong>zookeeper的作用</strong></h3><pre><code>1.数据发布与订阅（配置中心）
2.负载均衡
3.命名服务(Naming Service)
4.分布式通知/协调
5.集群管理与Master选举
6.分布式锁
7.分布式队列 ... 在分布式项目中作用巨大
</code></pre>
<h3 id="znode-节点"><a href="#znode-节点" class="headerlink" title="znode 节点"></a><strong>znode 节点</strong></h3><p>zookeeper 中数据基本单元叫节点，节点之下可包含子节点，最后以树级方式程现。每个节点拥有唯一的路径path。客户端基于PATH上传节点数据，zookeeper 收到后会实时通知对该路径进行监听的客户端。</p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk2.png" alt="图片"></p>
<p>zookeeper 基于JAVA开发，下载后只要有对应JVM环境即可运行。其默认的端口号是2181运行前得保证其不冲突</p>
<h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a><strong>版本说明</strong></h3><p>2019年5月20日发行的3.5.5是3.5分支的第一个稳定版本。此版本被认为是3.4稳定分支的后续版本，可以用于生产。基于3.4它包含以下新功能</p>
<ul>
<li>动态重新配置</li>
<li>本地会议</li>
<li>新节点类型：容器，TTL</li>
<li>原子广播协议的SSL支持</li>
<li>删除观察者的能力</li>
<li>多线程提交处理器</li>
<li>升级到Netty 4.1</li>
<li>Maven构建</li>
</ul>
<p>另请注意：建议的最低JDK版本为1.8<br>文件说明：</p>
<ul>
<li>apache-zookeeper-xxx-tar.gz 代表源代码</li>
<li>apache-zookeeper-xxx-bin.tar.gz 运行版本</li>
</ul>
<p>下载地址：<a target="_blank" rel="noopener" href="https://zookeeper.apache.org/releases.html#download">https://zookeeper.apache.org/releases.html#download</a><br>具体部署流程：</p>
<pre class="line-numbers language-none"><code class="language-none">#下载
wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;zookeeper&#x2F;current&#x2F;apache-zookeeper-3.5.5-bin.tar.gz
#解压
tar -zxvf apache-zookeeper-3.5.5-bin.tar.gz
#拷贝默认配置
cd  &#123;zookeeper_home&#125;&#x2F;conf 
cp zoo_sample.cfg zoo.cfg
#启动
 &#123;zookeeper_home&#125;&#x2F;bin&#x2F;zkServer.sh

 .&#x2F;bin&#x2F;zkServer.sh start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="常规配置文件说明"><a href="#常规配置文件说明" class="headerlink" title="常规配置文件说明"></a><strong>常规配置文件说明</strong></h3><pre class="line-numbers language-none"><code class="language-none"># zookeeper时间配置中的基本单位 (毫秒)
tickTime&#x3D;2000
# 允许follower初始化连接到leader最大时长，它表示tickTime时间倍数 即:initLimit*tickTime
initLimit&#x3D;10
# 允许follower与leader数据同步最大时长,它表示tickTime时间倍数 
syncLimit&#x3D;5
#zookeper 数据存储目录
dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper
#对客户端提供的端口号
clientPort&#x3D;2181
#单个客户端与zookeeper最大并发连接数
maxClientCnxns&#x3D;60
# 保存的数据快照数量，之外的将会被清除
autopurge.snapRetainCount&#x3D;3
#自动触发清除任务时间间隔，小时为单位。默认为0，表示不自动清除。
autopurge.purgeInterval&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a><strong>客户端命令</strong></h3><p><strong>基本命令列表</strong></p>
<pre class="line-numbers language-none"><code class="language-none"> 1.close
 关闭当前会话
 2.connect host:port 
 重新连接指定Zookeeper服务
 create [-s] [-e] [-c] [-t ttl] path [data] [acl]
 3.创建节点
 delete [-v version] path
 删除节点，(不能存在子节点）
 4.deleteall path
 删除路径及所有子节点
 5.setquota -n|-b val path
设置节点限额 -n 子节点数 -b 字节数
 6.listquota path
查看节点限额
 7.delquota [-n|-b] path
 删除节点限额
 8.get [-s] [-w] path
 查看节点数据 -s 包含节点状态 -w 添加监听 
 getAcl [-s] path
 9.ls [-s] [-w] [-R] path
 列出子节点 -s状态 -R 递归查看所有子节点 -w 添加监听
 10.printwatches on|off**
 是否打印监听事件
 11.quit 
 退出客户端
 12.history 
 查看执行的历史记录
 13.redo cmdno
 重复 执行命令，history 中命令编号确定
 14.removewatches path [-c|-d|-a] [-l]
 删除指定监听
 15.set [-s] [-v version] path data
 设置值
 16.setAcl [-s] [-v version] [-R] path acl
 为节点设置ACL权限
 17.stat [-w] path
 查看节点状态 -w 添加监听
 18.sync path
  强制同步节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>node数据的增删改查</strong></p>
<pre class="line-numbers language-none"><code class="language-none"># 列出子节点 
ls &#x2F;
#创建节点
create &#x2F;qiurunze &quot;qiurunze is good man&quot;
# 查看节点
get &#x2F;qiurunze
# 创建子节点 
create &#x2F;qiurunze&#x2F;sex &quot;man&quot;
# 删除节点
delete &#x2F;qiurunze&#x2F;sex
# 删除所有节点 包括子节点
deleteall &#x2F;qiurunze<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="三、Zookeeper节点介绍"><a href="#三、Zookeeper节点介绍" class="headerlink" title="三、Zookeeper节点介绍"></a>三、Zookeeper节点介绍</h2><hr>
<h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a><strong>知识点：</strong></h3><ol>
<li>节点类型</li>
<li>节点的监听(watch)</li>
<li>节点属性说明(stat)</li>
<li>权限设置(acl)</li>
</ol>
<p>zookeeper 中节点叫znode存储结构上跟文件系统类似，以树级结构进行存储。不同之外在于znode没有目录的概念，不能执行类似cd之类的命令。znode结构包含如下：</p>
<ul>
<li><strong>path</strong>:唯一路径 </li>
<li><strong>childNode</strong>：子节点</li>
<li><strong>stat</strong>:状态属性</li>
<li><strong>type</strong>:节点类型</li>
</ul>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PERSISTENT</td>
<td align="left">持久节点</td>
</tr>
<tr>
<td align="left">PERSISTENT_SEQUENTIAL</td>
<td align="left">持久序号节点</td>
</tr>
<tr>
<td align="left">EPHEMERAL</td>
<td align="left">临时节点(不可在拥有子节点)</td>
</tr>
<tr>
<td align="left">EPHEMERAL_SEQUENTIAL</td>
<td align="left">临时序号节点(不可在拥有子节点)</td>
</tr>
</tbody></table>
<ol>
<li>PERSISTENT（持久节点）</li>
</ol>
<p>持久化保存的节点，也是默认创建的</p>
<pre class="line-numbers language-none"><code class="language-none">#默认创建的就是持久节点
create &#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol>
<li>PERSISTENT_SEQUENTIAL(持久序号节点)</li>
</ol>
<p>创建时zookeeper 会在路径上加上序号作为后缀，。非常适合用于分布式锁、分布式选举等场景。创建时添加 -s 参数即可。</p>
<pre class="line-numbers language-none"><code class="language-none">#创建序号节点
create -s &#x2F;test
#返回创建的实际路径
Created &#x2F;test0000000001
create -s &#x2F;test
#返回创建的实际路径2
Created &#x2F;test0000000002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>EPHEMERAL（临时节点）</li>
</ol>
<p>临时节点会在客户端会话断开后自动删除。适用于心跳，服务发现等场景。创建时添加参数-e 即可。</p>
<pre class="line-numbers language-none"><code class="language-none">#创建临时节点， 断开会话 在连接将会自动删除
create -e &#x2F;temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol>
<li>EPHEMERAL_SEQUENTIAL（临时序号节点）</li>
</ol>
<p>与持久序号节点类似，不同之处在于EPHEMERAL_SEQUENTIAL是临时的会在会话断开后删除。创建时添加 -e -s </p>
<pre class="line-numbers language-none"><code class="language-none">create -e -s &#x2F;temp&#x2F;seq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a><strong>节点属性</strong></h3><pre class="line-numbers language-none"><code class="language-none"># 查看节点属性
stat &#x2F;qiurunze<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>其属性说明如下表：</p>
<pre class="line-numbers language-none"><code class="language-none">#创建节点的事物ID
cZxid &#x3D; 0x385
#创建时间
ctime &#x3D; Tue Sep 24 17:26:28 CST 2019
#修改节点的事物ID
mZxid &#x3D; 0x385
#最后修改时间
mtime &#x3D; Tue Sep 24 17:26:28 CST 2019
# 子节点变更的事物ID
pZxid &#x3D; 0x385
#这表示对此znode的子节点进行的更改次数（不包括子节点）
cversion &#x3D; 0
# 数据版本，变更次数
dataVersion &#x3D; 0
#权限版本，变更次数
aclVersion &#x3D; 0
#临时节点所属会话ID
ephemeralOwner &#x3D; 0x0
#数据长度
dataLength &#x3D; 17
#子节点数(不包括子子节点)
numChildren &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="节点的监听："><a href="#节点的监听：" class="headerlink" title="节点的监听："></a>节点的监听：</h3><p>客户添加 -w 参数可实时监听节点与子节点的变化，并且实时收到通知。非常适用保障分布式情况下的数据一至性。其使用方式如下：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ls -w path</td>
<td align="left">监听子节点的变化（增，删）</td>
</tr>
<tr>
<td align="left">get -w path</td>
<td align="left">监听节点数据的变化</td>
</tr>
<tr>
<td align="left">stat -w path</td>
<td align="left">监听节点属性的变化</td>
</tr>
<tr>
<td align="left">printwatches on|off</td>
<td align="left">触发监听后，是否打印监听事件(默认on)</td>
</tr>
</tbody></table>
<h3 id="acl权限设置"><a href="#acl权限设置" class="headerlink" title="acl权限设置"></a><strong>acl权限设置</strong></h3><p>ACL全称为Access Control List（访问控制列表），用于控制资源的访问权限。ZooKeeper使用ACL来控制对其znode的防问。基于scheme:id:permission的方式进行权限控制。scheme表示授权模式、id模式对应值、permission即具体的增删改权限位。</p>
<p><strong>scheme:认证模型</strong></p>
<table>
<thead>
<tr>
<th align="left">方案</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">world</td>
<td align="left">开放模式，world表示全世界都可以访问（这是默认设置）</td>
</tr>
<tr>
<td align="left">ip</td>
<td align="left">ip模式，限定客户端IP防问</td>
</tr>
<tr>
<td align="left">auth</td>
<td align="left">用户密码认证模式，只有在会话中添加了认证才可以防问</td>
</tr>
<tr>
<td align="left">digest</td>
<td align="left">与auth类似，区别在于auth用明文密码，而digest 用sha-1+base64加密后的密码。在实际使用中digest 更常见。</td>
</tr>
</tbody></table>
<p><strong>permission权限位</strong></p>
<table>
<thead>
<tr>
<th align="left">权限位</th>
<th align="left">权限</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">c</td>
<td align="left">CREATE</td>
<td align="left">可以创建子节点</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">DELETE</td>
<td align="left">可以删除子节点（仅下一级节点）</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">READ</td>
<td align="left">可以读取节点数据及显示子节点列表</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">WRITE</td>
<td align="left">可以设置节点数据</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">ADMIN</td>
<td align="left">可以设置节点访问控制列表权限</td>
</tr>
</tbody></table>
<p><strong>acl 相关命令：</strong></p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">使用方式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getAcl</td>
<td align="left">getAcl <path></path></td>
<td align="left">读取ACL权限</td>
</tr>
<tr>
<td align="left">setAcl</td>
<td align="left">setAcl <path></path> <acl></acl></td>
<td align="left">设置ACL权限</td>
</tr>
<tr>
<td align="left">addauth</td>
<td align="left">addauth <scheme> <auth></auth></scheme></td>
<td align="left">添加认证用户</td>
</tr>
</tbody></table>
<p><strong>world权限****示例</strong><br>语法： setAcl <path></path> world:anyone:&lt;权限位&gt;<br>注：world模式中anyone是唯一的值,表示所有人</p>
<ol>
<li><p>查看默认节点权限：</p>
<pre class="line-numbers language-none"><code class="language-none">#创建一个节点
create -e &#x2F;testAcl
#查看节点权限
getAcl &#x2F;testAcl
#返回的默认权限表示 ，所有人拥有所有权限。
&#39;world,&#39;anyone: cdrwa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>修改默认权限为 读写</p>
<pre class="line-numbers language-none"><code class="language-none">#设置为rw权限 
setAcl &#x2F;testAcl world:anyone:rw
# 可以正常读
get &#x2F;testAcl
# 无法正常创建子节点
create -e &#x2F;testAcl&#x2F;t &quot;hi&quot;
# 返回没有权限的异常
Authentication is not valid : &#x2F;testAcl&#x2F;t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p><strong>IP权限示例：</strong><br>语法： setAcl <path></path> ip:&lt;ip地址|地址段&gt;:&lt;权限位&gt;</p>
<p><strong>auth模式示例:</strong><br>语法： </p>
<ol>
<li>setAcl <path></path> auth:&lt;用户名&gt;:&lt;密码&gt;:&lt;权限位&gt;</li>
<li>addauth digest &lt;用户名&gt;:&lt;密码&gt;</li>
</ol>
<p><strong>digest 权限示例：</strong><br>语法： </p>
<ol>
<li>setAcl <path></path> digest :&lt;用户名&gt;:&lt;密钥&gt;:&lt;权限位&gt;</li>
<li>addauth digest &lt;用户名&gt;:&lt;密码&gt;</li>
</ol>
<p>注1：密钥 通过sha1与base64组合加密码生成，可通过以下命令生成</p>
<pre class="line-numbers language-none"><code class="language-none">echo -n &lt;用户名&gt;:&lt;密码&gt; | openssl dgst -binary -sha1 | openssl base64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注2：为节点设置digest 权限后，访问前必须执行addauth，当前会话才可以防问。</p>
<ol>
<li><p>设置digest 权限</p>
<pre class="line-numbers language-none"><code class="language-none">#先 sha1 加密，然后base64加密
echo -n qiurunze:123456 | openssl dgst -binary -sha1 | openssl base64
#返回密钥
2Rz3ZtRZEs5RILjmwuXW&#x2F;wT13Tk&#x3D;
#设置digest权限
setAcl &#x2F;qiurunze digest:qiurunze:2Rz3ZtRZEs5RILjmwuXW&#x2F;wT13Tk&#x3D;:cdrw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>查看节点将显示没有权限</p>
<pre class="line-numbers language-none"><code class="language-none">#查看节点
get &#x2F;qiurunze
#显示没有权限访问
org.apache.zookeeper.KeeperException$NoAuthException: KeeperErrorCode &#x3D; NoAuth for &#x2F;qiurunze<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>给当前会话添加认证后在次查看</p>
<pre class="line-numbers language-none"><code class="language-none">#给当前会话添加权限帐户
addauth digest qiurunze:123456
#在次查看
get &#x2F;qiurunze
#获得返回结果
qiurunze is good man<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>ACL的特殊说明：<br>权限仅对当前节点有效，不会让子节点继承。如限制了IP防问A节点，但不妨碍该IP防问A的子节点 &#x2F;A&#x2F;B。</p>
<p><strong>zk进阶–集群–选举-数据一致</strong></p>
<h3 id="一、客户端API常规应用-项目为-com-zkdesign-zookeeper目录下"><a href="#一、客户端API常规应用-项目为-com-zkdesign-zookeeper目录下" class="headerlink" title="一、客户端API常规应用 项目为 com.zkdesign.zookeeper目录下"></a>一、客户端API常规应用 项目为 com.zkdesign.zookeeper目录下</h3><p>zookeeper 提供了java与C两种语言的客户端。我们要学习的就是java客户端。引入最新的maven依赖：<br> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.5.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><strong>知识点</strong></h4><ol>
<li>初始连接</li>
<li>创建、查看节点</li>
<li>监听节点</li>
<li>设置节点权限</li>
<li>第三方客户端ZkClient</li>
</ol>
<h4 id="初始连接"><a href="#初始连接" class="headerlink" title="初始连接"></a><strong>初始连接</strong></h4><pre><code> 常规的客户端类是 org.apache.zookeeper.ZooKeeper，实例化该类之后将会自动与集群建立连接。构造参数说明如下：
 | 参数名称   | 类型   | 说明   | 
 |:----|:----|:----|:----:|
 | connectString   | String    | 连接串，包括ip+端口 ,集群模式下用逗号隔开  192.168.0.149:2181,192.168.0.150:2181   | 
 | sessionTimeout   | **int **   | 会话超时时间，该值不能超过服务端所设置的  *minSessionTimeout 和maxSessionTimeout*   | 
 | watcher   | Watcher    | 会话监听器，服务端事件将会触该监听   | 
 | sessionId   | **long **   | 自定义会话ID   | 
 | sessionPasswd   | **byte**[]   | 会话密码   | 
 | canBeReadOnly   | **boolean **   | 该连接是否为只读的   | 
 | hostProvider   | HostProvider    | 服务端地址提供者，指示客户端如何选择某个服务来调用，默认采用StaticHostProvider实现   | 
</code></pre>
<h4 id="创建、查看节点"><a href="#创建、查看节点" class="headerlink" title="创建、查看节点"></a><strong>创建、查看节点</strong></h4><pre><code> 通过org.apache.zookeeper.ZooKeeper#create()即可创建节点，其参数说明如下：
 | 参数名称 | 类型 | 说明 | 
 |:----|:----|:----|
 | path   | String    |    | 
 | data   | byte[]   |    | 
 | acl   | List&lt;ACL&gt;   |    | 
 | createMode   | CreateMode    |    | 
 | cb     | StringCallback    |    | 
 | ctx   | Object    |    | 
</code></pre>
<h4 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a><strong>查看节点</strong></h4><pre><code> 通过org.apache.zookeeper.ZooKeeper#getData()即可创建节点，其参数说明如下：
 | 参数名称 | 类型 | 说明 | 
 |:----|:----|:----|
 | path   | String    |    | 
 | watch   | **boolean **   |    | 
 | watcher   | Watcher    |    | 
 | cb   | DataCallback    |    | 
 | ctx   | Object    |    | 
</code></pre>
<h4 id="查看子节点"><a href="#查看子节点" class="headerlink" title="查看子节点"></a><strong>查看子节点</strong></h4><pre><code> 通过org.apache.zookeeper.ZooKeeper#getChildren()即可获取子节点，其参数说明如下：
 | 参数名称 | 类型 | 说明 | 
 |:----:|:----:|:----|
 | path | String  |    | 
 | watch | **boolean **   |    | 
 | watcher | Watcher  |    | 
 | cb | Children2Callback   |    | 
 | ctx | Object  |    | 
</code></pre>
<h4 id="监听节点"><a href="#监听节点" class="headerlink" title="监听节点"></a><strong>监听节点</strong></h4><p>在getData() 与getChildren()两个方法中可分别设置监听数据变化和子节点变化。通过设置watch为true，当前事件触发时会调用zookeeper()构建函数中Watcher.process()方法。也可以添加watcher参数来实现自定义监听。一般采用后者。<br>注：所有的监听都是一次性的，如果要持续监听需要触发后在添加一次监听</p>
<h4 id="4-设置节点ACL权限"><a href="#4-设置节点ACL权限" class="headerlink" title="4.设置节点ACL权限"></a><strong>4.设置节点ACL权限</strong></h4><p>ACL包括结构为scheme:id:permission<br>客户端中由org.apache.zookeeper.data.ACL 类表示，类结构如下：</p>
<pre><code> 1. ACL 
   1. Id
     1. scheme       // 对应权限模式scheme
     2. id                 // 对应模式中的id值
   2. perms               // 对应权限位permission
</code></pre>
<p>关于权限位的表示方式：<br>每个权限位都是一个唯一数字，将其合时通过或运行生成一个全新的数字即可<br> <pre class="line-numbers language-none"><code class="language-none">@InterfaceAudience.Public
public interface Perms &#123;
    int READ &#x3D; 1 &lt;&lt; 0;
    int WRITE &#x3D; 1 &lt;&lt; 1;
    int CREATE &#x3D; 1 &lt;&lt; 2;
    int DELETE &#x3D; 1 &lt;&lt; 3;
    int ADMIN &#x3D; 1 &lt;&lt; 4;

    int ALL &#x3D; READ | WRITE | CREATE | DELETE | ADMIN;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h4 id="5-第三方客户端ZkClient"><a href="#5-第三方客户端ZkClient" class="headerlink" title="5.第三方客户端ZkClient"></a><strong>5.第三方客户端ZkClient</strong></h4><p>zkClient 是在zookeeper客户端基础之上封装的，使用上更加友好。主要变化如下：</p>
<ul>
<li>可以设置持久监听，或删除某个监听</li>
<li>可以插入JAVA对象，自动进行序列化和反序列化</li>
<li>简化了基本的增删改查操作。</li>
</ul>
<h2 id="二、Zookeeper集群"><a href="#二、Zookeeper集群" class="headerlink" title="二、Zookeeper集群"></a>二、Zookeeper集群</h2><h3 id="知识点：-1"><a href="#知识点：-1" class="headerlink" title="知识点："></a>知识点：</h3><pre><code> 1. 集群部署
 2. 集群角色说明
 3. 选举机制
 4. 数据提交机制
 5. 集群配置说明
</code></pre>
<p>zookeeper集群的目的是为了保证系统的性能承载更多的客户端连接设专门提供的机制。通过集群可以实现以下功能：</p>
<ul>
<li>读写分离：提高承载，为更多的客户端提供连接，并保障性能。</li>
<li>主从自动切换：提高服务容错性，部分节点故障不会影响整个服务集群。</li>
</ul>
<p><strong>半数以上运行机制说明：</strong><br>集群至少需要三台服务器，并且强烈建议使用奇数个服务器。因为zookeeper 通过判断大多数节点的存活来判断整个服务是否可用,比如3个节点，挂掉了2个表示整个集群挂掉，<br>而用偶数4个，挂掉了2个也表示其并不是大部分存活，因此也会挂掉</p>
<h4 id="1-集群部署-注意数据库连接的端口号和通信的端口号不是一个"><a href="#1-集群部署-注意数据库连接的端口号和通信的端口号不是一个" class="headerlink" title="1. 集群部署 注意数据库连接的端口号和通信的端口号不是一个"></a>1. 集群部署 注意数据库连接的端口号和通信的端口号不是一个</h4><p>配置语法：<br>server.&lt;节点ID&gt;&#x3D;<ip>:&lt;数据同步端口&gt;:&lt;选举端口&gt;</ip></p>
<ul>
<li><strong>节点****ID</strong>：服务id手动指定1至125之间的数字，并写到对应服务节点的 {dataDir}&#x2F;myid 文件中。</li>
<li><strong>IP地址：</strong>节点的远程IP地址，可以相同。但生产环境就不能这么做了，因为在同一台机器就无法达到容错的目的。所以这种称作为伪集群。</li>
<li><strong>数据同步端口：</strong>主从同时数据复制端口，（做伪集群时端口号不能重复）。</li>
<li><strong>远举端口：</strong>主从节点选举端口，（做伪集群时端口号不能重复）。</li>
</ul>
<p>配置文件示例：<br> <pre class="line-numbers language-none"><code class="language-none">tickTime&#x3D;2000
dataDir&#x3D;&#x2F;var&#x2F;lib&#x2F;zookeeper&#x2F;
clientPort&#x3D;2181
initLimit&#x3D;5
syncLimit&#x3D;2
#以下为集群配置，必须配置在所有节点的zoo.cfg文件中
server.1&#x3D;zoo1:2888:3888
server.2&#x3D;zoo2:2888:3888
server.3&#x3D;zoo3:2888:3888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h4 id="集群配置流程："><a href="#集群配置流程：" class="headerlink" title="集群配置流程："></a><strong>集群配置流程：</strong></h4><ol>
<li>分别创建3个data目录用于存储各节点数据 <pre class="line-numbers language-none"><code class="language-none">mkdir data
mkdir data&#x2F;1
mkdir data&#x2F;3
mkdir data&#x2F;3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>编写myid文件 <pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; data&#x2F;1&#x2F;myid
echo 3 &gt; data&#x2F;3&#x2F;myid
echo 2 &gt; data&#x2F;2&#x2F;myid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
3、编写配置文件<br><em>conf&#x2F;zoo1.cfg</em> <pre class="line-numbers language-none"><code class="language-none">tickTime&#x3D;2000
initLimit&#x3D;10
syncLimit&#x3D;5
dataDir&#x3D;data&#x2F;1
clientPort&#x3D;2181
#集群配置
server.1&#x3D;127.0.0.1:2887:3887
server.2&#x3D;127.0.0.1:2888:3888
server.3&#x3D;127.0.0.1:2889:3889<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p><em>conf&#x2F;zoo2.cfg</em><br> <pre class="line-numbers language-none"><code class="language-none">tickTime&#x3D;2000
initLimit&#x3D;10
syncLimit&#x3D;5
dataDir&#x3D;data&#x2F;2
clientPort&#x3D;2182
#集群配置
server.1&#x3D;127.0.0.1:2887:3887
server.2&#x3D;127.0.0.1:2888:3888
server.3&#x3D;127.0.0.1:2889:3889<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<p><em>conf&#x2F;zoo3.cfg</em><br> <pre class="line-numbers language-none"><code class="language-none">tickTime&#x3D;2000
initLimit&#x3D;10
syncLimit&#x3D;5
dataDir&#x3D;data&#x2F;3
clientPort&#x3D;2183
#集群配置
server.1&#x3D;127.0.0.1:2887:3887
server.2&#x3D;127.0.0.1:2888:3888
server.3&#x3D;127.0.0.1:2889:3889<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<p>4.分别启动<br> <pre class="line-numbers language-none"><code class="language-none">.&#x2F;bin&#x2F;zkServer.sh start conf&#x2F;zoo1.cfg
.&#x2F;bin&#x2F;zkServer.sh start conf&#x2F;zoo2.cfg
.&#x2F;bin&#x2F;zkServer.sh start conf&#x2F;zoo3.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p>
<p>5.分别查看状态<br> <pre class="line-numbers language-none"><code class="language-none">.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo1.cfg
Mode: follower
.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo2.cfg
Mode: leader
.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo3.cfg
Mode: follower<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<p><strong>检查集群复制情况：</strong><br>1、分别连接指定节点<br>zkCli.sh 后加参数-server 表示连接指定IP与端口。<br> <pre class="line-numbers language-none"><code class="language-none">.&#x2F;bin&#x2F;zkCli.sh -server 127.0.0.1:2181
.&#x2F;bin&#x2F;zkCli.sh -server 127.0.0.1:2182
.&#x2F;bin&#x2F;zkCli.sh -server 127.0.0.1:2183<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p>
<ul>
<li><input disabled type="checkbox"> 任意节点中创建数据，查看其它节点已经同步成功。</li>
</ul>
<p>注意： -server参数后同时连接多个服务节点，并用逗号隔开 127.0.0.1:2181,127.0.0.1:2182</p>
<h4 id="1-集群角色说明"><a href="#1-集群角色说明" class="headerlink" title="1. 集群角色说明"></a>1. 集群角色说明</h4><pre><code> zookeeper 集群中总共有三种角色，分别是leader（主节点）follower(子节点) observer（次级子节点）
     | 角色   | 描述   | 
     |:----|:----|
     | **leader**   | 主节点，又名领导者。用于写入数据，通过选举产生，如果宕机将会选举新的主节点。   | 
     | **follower**   | 子节点，又名追随者。用于实现数据的读取。同时他也是主节点的备选节点，并用拥有投票权。   | 
     | **observer**   | 次级子节点，又名观察者。用于读取数据，与fllower区别在于没有投票权，不能选为主节点。并且在计算集群可用状态时不会将observer计算入内。   | 
</code></pre>
<p><strong>observer配置：</strong><br>只要在集群配置中加上observer后缀即可，示例如下：<br> <pre class="line-numbers language-none"><code class="language-none">server.3&#x3D;127.0.0.1:2889:3889:observer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>
<h3 id="3-选举机制"><a href="#3-选举机制" class="headerlink" title="3.选举机制"></a>3.选举机制</h3><p>通过 .&#x2F;bin&#x2F;zkServer.sh status &lt;zoo配置文件&gt; 命令可以查看到节点状态</p>
 <pre class="line-numbers language-none"><code class="language-none">.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo1.cfg
Mode: follower
.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo2.cfg
Mode: leader
.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo3.cfg
Mode: follower<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现中间的2182 是leader状态.其选举机制如下图：</p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk7.png" alt="图片"></p>
<p><strong>投票机制说明：</strong><br>第一轮投票全部投给自己<br>第二轮投票给myid比自己大的相邻节点<br>如果得票超过半数，选举结束。</p>
<p><strong>选举触发：</strong><br>当集群中的服务器出现已下两种情况时会进行Leader的选举</p>
<ol>
<li>服务节点初始化启动</li>
<li>半数以上的节点无法和Leader建立连接</li>
</ol>
<p>当节点初始起动时会在集群中寻找Leader节点，如果找到则与Leader建立连接，其自身状态变化<strong>follower</strong>或<strong>observer。</strong>如果没有找到Leader，当前节点状态将变化LOOKING，进入选举流程。<br>在集群运行其间如果有follower或observer节点宕机只要不超过半数并不会影响整个集群服务的正常运行。但如果leader宕机，将暂停对外服务，所有follower将进入LOOKING 状态，进入选举流程。</p>
<ol>
<li>数据同步机制</li>
</ol>
<p>zookeeper 的数据同步是为了保证各节点中数据的一至性，同步时涉及两个流程，一个是正常的客户端数据提交，另一个是集群某个节点宕机在恢复后的数据同步。</p>
<p><strong>客户端写入请求：</strong></p>
<p>写入请求的大至流程是，收leader接收客户端写请求，并同步给各个子节点。如下图：<br><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk4.png" alt="图片"><br>但实际情况要复杂的多，比如client 它并不知道哪个节点是leader 有可能写的请求会发给follower ，由follower在转发给leader进行同步处理<br><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk5.png" alt="图片"></p>
<p>客户端写入流程说明：</p>
<ol>
<li>client向zk中的server发送写请求，如果该server不是leader，则会将该写请求转发给leader server，leader将请求事务以proposal形式分发给follower；</li>
<li>当follower收到收到leader的proposal时，根据接收的先后顺序处理proposal；</li>
<li>当Leader收到follower针对某个proposal过半的ack后，则发起事务提交，重新发起一个commit的proposal</li>
<li>Follower收到commit的proposal后，记录事务提交，并把数据更新到内存数据库；</li>
<li>当写成功后，反馈给client。</li>
</ol>
<p><strong>服务节点初始化同步：</strong><br>在集群运行过程当中如果有一个follower节点宕机，由于宕机节点没过半，集群仍然能正常服务。当leader 收到新的客户端请求，此时无法同步给宕机的节点。造成数据不一至。为了解决这个问题，当节点启动时，第一件事情就是找当前的Leader，比对数据是否一至。不一至则开始同步,同步完成之后在进行对外提供服务。<br>如何比对Leader的数据版本呢，这里通过ZXID事物ID来确认。比Leader小就需要同步。<br><strong>ZXID说明：</strong>投票机制说明<br>ZXID是一个长度64位的数字，其中低32位是按照数字递增，任何数据的变更都会导致,低32位的数字简单加1。高32位是leader周期编号，每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的周期编号，进行加1，再将低32位的全部设置为0。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是保证递增的。</p>
<p><strong>思考题：</strong><br>如果leader 节点宕机，在恢复后它还能被选为leader吗？</p>
<h3 id="5-四字运维命令"><a href="#5-四字运维命令" class="headerlink" title="5.四字运维命令"></a>5.四字运维命令</h3><p>ZooKeeper响应少量命令。每个命令由四个字母组成。可通过telnet或nc向ZooKeeper发出命令。<br>这些命令默认是关闭的，需要配置4lw.commands.whitelist来打开，可打开部分或全部示例如下：<br> <pre class="line-numbers language-none"><code class="language-none">#打开指定命令
4lw.commands.whitelist&#x3D;stat, ruok, conf, isro
#打开全部
4lw.commands.whitelist&#x3D;*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p>
<p>安装Netcat工具，已使用nc命令<br> <pre class="line-numbers language-none"><code class="language-none">#安装Netcat 工具
yum install -y nc
#查看服务器及客户端连接状态
echo stat | nc localhost 2181<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br><strong>命令列表</strong></p>
<pre><code> 1. conf：3.3.0中的新增功能：打印有关服务配置的详细信息。
 2. 缺点：3.3.0中的新增功能：列出了连接到该服务器的所有客户端的完整连接/会话详细信息。包括有关已接收/已发送的数据包数量，会话ID，操作等待时间，最后执行的操作等信息。
 3. crst：3.3.0中的新增功能：重置所有连接的连接/会话统计信息。
 4. dump：列出未完成的会话和临时节点。这仅适用于领导者。
 5. envi：打印有关服务环境的详细信息
 6. ruok：测试服务器是否以非错误状态运行。如果服务器正在运行，它将以imok响应。否则，它将完全不响应。响应“ imok”不一定表示服务器已加入仲裁，只是服务器进程处于活动状态并绑定到指定的客户端端口。使用“ stat”获取有关状态仲裁和客户端连接信息的详细信息。
 7. srst：重置服务器统计信息。
 8. srvr：3.3.0中的新功能：列出服务器的完整详细信息。
 9. stat：列出服务器和连接的客户端的简要详细信息。
 10. wchs：3.3.0中的新增功能：列出有关服务器监视的简要信息。
 11. wchc：3.3.0中的新增功能：按会话列出有关服务器监视的详细信息。这将输出具有相关监视（路径）的会话（连接）列表。请注意，根据手表的数量，此操作可能会很昂贵（即影响服务器性能），请小心使用。
 12. dirs：3.5.1中的新增功能：以字节为单位显示快照和日志文件的总大小
 13. wchp：3.3.0中的新增功能：按路径列出有关服务器监视的详细信息。这将输出具有关联会话的路径（znode）列表。请注意，根据手表的数量，此操作可能会很昂贵（即影响服务器性能），请小心使用。
 14. mntr：3.4.0中的新增功能：输出可用于监视集群运行状况的变量列表。
</code></pre>
<h1 id="1-zk进阶–集群–分布式管理–注册中心–分布式JOB–分布式锁"><a href="#1-zk进阶–集群–分布式管理–注册中心–分布式JOB–分布式锁" class="headerlink" title="1.zk进阶–集群–分布式管理–注册中心–分布式JOB–分布式锁*"></a>1.<em>zk进阶–集群–分布式管理–注册中心–分布式JOB–分布式锁</em>*</h1><h2 id="一、-分布式集群管理"><a href="#一、-分布式集群管理" class="headerlink" title="一、 分布式集群管理"></a>一、 分布式集群管理</h2><hr>
<h3 id="分布式集群管理的需求"><a href="#分布式集群管理的需求" class="headerlink" title="分布式集群管理的需求"></a><strong>分布式集群管理的需求</strong></h3><pre><code>1. 主动查看线上服务节点
2. 查看服务节点资源使用情况
3. 服务离线通知
4. 服务资源（CPU、内存、硬盘）超出阀值通知
</code></pre>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a><strong>架构设计</strong></h3><p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk8.png" alt="图片"></p>
<p><strong>节点结构：</strong></p>
<ol>
<li>qiurunze-manger &#x2F;&#x2F; 根节点</li>
<li>server00001 :<json> &#x2F;&#x2F;服务节点 1</json></li>
<li>server00002 :<json>&#x2F;&#x2F;服务节点 2</json></li>
<li>server……..n :<json>&#x2F;&#x2F;服务节点 n</json></li>
</ol>
<p>服务状态信息:</p>
<ol>
<li>ip</li>
<li>cpu</li>
<li>memory</li>
<li>disk</li>
</ol>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a><strong>功能实现</strong></h3><p><strong>数据生成与上报：</strong></p>
<ol>
<li>创建临时节点：</li>
<li>定时变更节点状态信息：</li>
</ol>
<p><strong>主动查询：</strong><br>1、实时查询 zookeeper 获取集群节点的状态信息。<br><strong>被动通知：</strong></p>
<ol>
<li>监听根节点下子节点的变化情况,如果CPU 等硬件资源低于警告位则发出警报。</li>
</ol>
<p><strong>关键示例代码：</strong></p>
<p>zkdesign-hardcode Agent类 可查看</p>
<p>实现效果图：<br><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk9.png" alt="图片"></p>
<h2 id="二-、分布式注册中心"><a href="#二-、分布式注册中心" class="headerlink" title="二 、分布式注册中心"></a>二 、分布式注册中心</h2><hr>
<p>在单体式服务中，通常是由多个客户端去调用一个服务，只要在客户端中配置唯一服务节点地址即可，当升级到分布式后，服务节点变多，像阿里一线大厂服务节点更是上万之多，这么多节点不可能手动配置在客户端，这里就需要一个中间服务，专门用于帮助客户端发现服务节点，即许多技术书籍经常提到的<strong>服务发现</strong>。<br><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk10.png" alt="图片"></p>
<p>一个完整的注册中心涵盖以下功能特性：</p>
<ul>
<li><strong>服务注册：</strong>提供者上线时将自提供的服务提交给注册中心。</li>
<li><strong>服务注销：</strong>通知注册心提供者下线。</li>
<li><strong>服务订阅</strong>：动态实时接收服务变更消息。</li>
<li><strong>可靠</strong>：注册服务本身是集群的，数据冗余存储。避免单点故障，及数据丢失。</li>
<li><strong>容错</strong>：当服务提供者出现宕机，断电等极情况时，注册中心能够动态感知并通知客户端服务提供者的状态。</li>
</ul>
<h3 id="Dubbo-对zookeeper的使用"><a href="#Dubbo-对zookeeper的使用" class="headerlink" title="Dubbo 对zookeeper的使用"></a><strong>Dubbo 对zookeeper的使用</strong></h3><p>阿里著名的开源项目Dubbo 是一个基于JAVA的RCP框架，其中必不可少的注册中心可基于多种第三方组件实现，但其官方推荐的还是Zookeeper做为注册中心服务。<br><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk11.png" alt="图片"></p>
<h3 id="Dubbo-Zookeeper注册中心存储结构："><a href="#Dubbo-Zookeeper注册中心存储结构：" class="headerlink" title="Dubbo Zookeeper注册中心存储结构："></a><strong>Dubbo Zookeeper注册中心存储结构：</strong></h3><p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk12.png" alt="图片"></p>
<p><strong>节点说明：</strong></p>
<pre><code>| **类别**   | **属性**   | **说明**   | 
|:----|:----|:----|
| **Root**   | 持久节点   | 根节点名称，默认是 &quot;dubbo&quot;   | 
| **Service**   | 持久节点   | 服务名称，完整的服务类名   | 
| **type**   | 持久节点   | 可选值：providers(提供者)、consumers（消费者）、configurators(动态配置)、routers   | 
| **URL**   | 临时节点   | url名称 包含服务提供者的 IP 端口 及配置等信息。   | 
</code></pre>
<h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a><strong>流程说明</strong></h3><ol>
<li>服务提供者启动时: 向 &#x2F;dubbo&#x2F;com.foo.BarService&#x2F;providers 目录下写入自己的 URL 地址</li>
<li>服务消费者启动时: 订阅 &#x2F;dubbo&#x2F;com.foo.BarService&#x2F;providers 目录下的提供者 URL 地址。并向 &#x2F;dubbo&#x2F;com.foo.BarService&#x2F;consumers 目录下写入自己的 URL 地址</li>
<li>监控中心启动时: 订阅 &#x2F;dubbo&#x2F;com.foo.BarService 目录下的所有提供者和消费者 URL 地址</li>
</ol>
<h3 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a><strong>示例演示</strong></h3><p>服务端代码：<br>在 zkdesign-dubboexample – 举例 ： Server Clent</p>
<p>查询zk 实际存储内容：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;dubbo
&#x2F;dubbo&#x2F;com.zkdesign.zk.dubbo.UserService
&#x2F;dubbo&#x2F;com.zkdesign.zk.dubbo.UserService&#x2F;configurators
&#x2F;dubbo&#x2F;com.zkdesign.zk.dubbo.UserService&#x2F;routers

&#x2F;dubbo&#x2F;com.zkdesign.zk.dubbo.UserService&#x2F;providers
&#x2F;dubbo&#x2F;com.zkdesign.zk.dubbo.UserService&#x2F;providers&#x2F;dubbo:&#x2F;&#x2F;192.168.0.132:20880&#x2F;com.qiurunze.zk.dubbo.UserService?anyhost&#x3D;true&amp;application&#x3D;simple-app&amp;dubbo&#x3D;2.6.2&amp;generic&#x3D;false&amp;interface&#x3D;com.qiurunze.zk.dubbo.UserService&amp;methods&#x3D;getUser&amp;pid&#x3D;11128&amp;side&#x3D;provider&amp;threads&#x3D;200&amp;timestamp&#x3D;1570518302772
&#x2F;dubbo&#x2F;com.zkdesign.zk.dubbo.UserService&#x2F;providers&#x2F;dubbo:&#x2F;&#x2F;192.168.0.132:20881&#x2F;com.qiurunze.zk.dubbo.UserService?anyhost&#x3D;true&amp;application&#x3D;simple-app&amp;dubbo&#x3D;2.6.2&amp;generic&#x3D;false&amp;interface&#x3D;com.qiurunze.zk.dubbo.UserService&amp;methods&#x3D;getUser&amp;pid&#x3D;12956&amp;side&#x3D;provider&amp;threads&#x3D;200&amp;timestamp&#x3D;1570518532382
&#x2F;dubbo&#x2F;com.zkdesign.zk.dubbo.UserService&#x2F;providers&#x2F;dubbo:&#x2F;&#x2F;192.168.0.132:20882&#x2F;com.qiurunze.zk.dubbo.UserService?anyhost&#x3D;true&amp;application&#x3D;simple-app&amp;dubbo&#x3D;2.6.2&amp;generic&#x3D;false&amp;interface&#x3D;com.qiurunze.zk.dubbo.UserService&amp;methods&#x3D;getUser&amp;pid&#x3D;2116&amp;side&#x3D;provider&amp;threads&#x3D;200&amp;timestamp&#x3D;1570518537021

&#x2F;dubbo&#x2F;com.zkdesign.zk.dubbo.UserService&#x2F;consumers
&#x2F;dubbo&#x2F;com.zkdesign.zk.dubbo.UserService&#x2F;consumers&#x2F;consumer:&#x2F;&#x2F;192.168.0.132&#x2F;com.qiurunze.zk.dubbo.UserService?application&#x3D;young-app&amp;category&#x3D;consumers&amp;check&#x3D;false&amp;dubbo&#x3D;2.6.2&amp;interface&#x3D;com.qiurunze.zk.dubbo.UserService&amp;methods&#x3D;getUser&amp;pid&#x3D;9200&amp;side&#x3D;consumer&amp;timeout&#x3D;5000&amp;timestamp&#x3D;1570518819628<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 这些节点下 只有privider 和 consumer 底下的节点是 临时节点 其他的都是持久节点</p>
<h2 id="三、分布式JOB"><a href="#三、分布式JOB" class="headerlink" title="三、分布式JOB"></a>三、分布式JOB</h2><hr>
<h3 id="分布式JOB需求："><a href="#分布式JOB需求：" class="headerlink" title="分布式JOB需求："></a>分布式JOB需求：</h3><ol>
<li>多个服务节点只允许其中一个主节点运行JOB任务。</li>
<li>当主节点挂掉后能自动切换主节点，继续执行JOB任务。</li>
</ol>
<h3 id="架构设计："><a href="#架构设计：" class="headerlink" title="架构设计："></a>架构设计：</h3><p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk13.png" alt="图片"><br><strong>node结构：</strong></p>
<ol>
<li>qiurunze-master</li>
<li>server0001:master</li>
<li>server0002:slave</li>
<li>server000n:slave</li>
</ol>
<p><strong>选举流程：</strong><br>服务启动：</p>
<ol>
<li>在qiurunze-maste下创建server子节点，值为slave</li>
<li>获取所有qiurunze-master 下所有子节点</li>
<li>判断是否存在master 节点</li>
<li>如果没有设置自己为master节点</li>
</ol>
<p>子节点删除事件触发：</p>
<ol>
<li>获取所有qiurunze-master 下所有子节点</li>
<li>判断是否存在master 节点</li>
<li>如果没有设置最小值序号为master 节点</li>
</ol>
<h2 id="四、分布式锁"><a href="#四、分布式锁" class="headerlink" title="四、分布式锁"></a>四、分布式锁</h2><hr>
<h3 id="锁的的基本概念："><a href="#锁的的基本概念：" class="headerlink" title="锁的的基本概念："></a><strong>锁的的基本概念：</strong></h3><p>开发中锁的概念并不陌生，通过锁可以实现在多个线程或多个进程间在争抢资源时，能够合理的分配置资源的所有权<br>在单体应用中我们可以通过 synchronized 或ReentrantLock 来实现锁。但在分布式系统中，仅仅是加synchronized 是不够的，需要借助第三组件来实现。比如一些简单的做法是使用 关系型数据行级锁来实现不同进程之间的互斥，但大型分布式系统的性能瓶颈往往集中在数据库操作上。为了提高性能得采用如Redis、Zookeeper之内的组件实现分布式锁。</p>
<p><strong>共享锁：</strong>也称作只读锁，当一方获得共享锁之后，其它方也可以获得共享锁。但其只允许读取。在共享锁全部释放之前，其它方不能获得写锁。<br><strong>排它锁：</strong>也称作读写锁，获得排它锁后，可以进行数据的读写。在其释放之前，其它方不能获得任何锁。</p>
<h3 id="锁的获取："><a href="#锁的获取：" class="headerlink" title="锁的获取："></a>锁的获取：</h3><p>某银行帐户，可以同时进行帐户信息的读取，但读取其间不能修改帐户数据。其帐户ID为:888</p>
<ul>
<li>获得读锁流程：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk14.png" alt="图片"><br>1、基于资源ID创建临时序号读锁节点<br>&#x2F;lock&#x2F;888.R0000000002 Read<br>2、获取 &#x2F;lock 下所有子节点，判断其最小的节点是否为读锁，如果是则获锁成功<br>3、最小节点不是读锁，则阻塞等待。添加lock&#x2F; 子节点变更监听。<br>4、当节点变更监听触发，执行第2步</p>
<p><strong>数据结构：</strong><br><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk15.png" alt="图片"></p>
<ul>
<li>获得写锁：</li>
</ul>
<p>1、基于资源ID创建临时序号写锁节点<br>&#x2F;lock&#x2F;888.R0000000002 Write<br>2、获取 &#x2F;lock 下所有子节点，判断其最小的节点是否为自己，如果是则获锁成功<br>3、最小节点不是自己，则阻塞等待。添加lock&#x2F; 子节点变更监听。<br>4、当节点变更监听触发，执行第2步</p>
<ul>
<li>释放锁：</li>
</ul>
<p>读取完毕后，手动删除临时节点，如果获锁期间宕机，则会在会话失效后自动删除。</p>
<h3 id="关于羊群效应："><a href="#关于羊群效应：" class="headerlink" title="关于羊群效应："></a><strong>关于羊群效应：</strong></h3><p>在等待锁获得期间，所有等待节点都在监听 Lock节点，一但lock 节点变更所有等待节点都会被触发，然后在同时反查Lock 子节点。如果等待对列过大会使用Zookeeper承受非常大的流量压力。</p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk17.png" alt="图片"></p>
<p>为了改善这种情况，可以采用监听链表的方式，每个等待对列只监听前一个节点，如果前一个节点释放锁的时候，才会被触发通知。这样就形成了一个监听链表。<br><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk18.png" alt="图片"></p>
<h3 id="示例演示："><a href="#示例演示：" class="headerlink" title="示例演示："></a><strong>示例演示：</strong></h3><p><a target="_blank" rel="noopener" href="http://blog.itpub.net/31562040/viewspace-2640310/">http://blog.itpub.net/31562040/viewspace-2640310/</a>  参考</p>
<h1 id="ZAB协议流程实现源码分析"><a href="#ZAB协议流程实现源码分析" class="headerlink" title="ZAB协议流程实现源码分析*"></a><em>ZAB协议流程实现源码分析</em>*</h1><h2 id="什么是ZAB协议"><a href="#什么是ZAB协议" class="headerlink" title="什么是ZAB协议"></a>什么是ZAB协议</h2><p>Zookeeper主要操作数据的状态，为了保证状态的一致性，Zookeeper提出了两个安全属性</p>
<h2 id><a href="#" class="headerlink" title></a><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk26.png" alt="图片"></h2><p>Zookeeper 使用一个单一主进程来接收并处理客户端的所有事务请求，即写请求 当服 务器数据的状态发生变更后，<br>集群采用 ZAB 原子广播协议，以事务提案 Proposal 的形式广 播到所有的副本进程上 ZAB 协议能够保证一个全局的变更序列、<br>即可以为每一个事务分配 一个全局的递增编号 xid</p>
<p>当 Zookeeper 客户端连接到 Zookeeper 集群的一个节点后，若客户端提交的是读请求， 那么当前节点就直接根据自己保存的数据对其进行响应<br>如果是写请求且当前节点不是 Leader，那么节点就会将该写请求转发给 Leader，Leader 会以提案的方式广播该写操作，只要有超过半数节点同意<br>该写操作，则该写操作请求就会被提交 然后 Leader 会再次广播给 所有订阅者，即 Learner，通知它们同步数据</p>
<h3 id="ZAB协议原理"><a href="#ZAB协议原理" class="headerlink" title="ZAB协议原理"></a>ZAB协议原理</h3><p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk28.png" alt="图片"></p>
<h3 id="ZAB核心原理"><a href="#ZAB核心原理" class="headerlink" title="ZAB核心原理"></a>ZAB核心原理</h3><p>Zab协议的核心：定义了事务请求的处理方式</p>
<p>1.所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做 Leader服务器 其他剩余的服务器则是 Follower服务器</p>
<p>2.Leader服务器 负责将一个客户端事务请求，转换成一个 事务Proposal，并将该 Proposal 分发给集群中所有的 Follower 服务器，也就是向所有 Follower 节点发送数据广播请求（或数据复制）</p>
<p>3.分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），在Zab协议中，只要超过半数的Follower服务器进行了正确的反馈后（也就是收到半数以上的Follower的Ack请求<br>那么 Leader 就会再次向所有的 Follower服务器发送 Commit 消息，要求其将上一个 事务proposal 进行提交</p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk29.png" alt="图片"></p>
<h3 id="ZAB协议内容"><a href="#ZAB协议内容" class="headerlink" title="ZAB协议内容"></a>ZAB协议内容</h3><p>Zab 协议包括两种基本的模式：崩溃恢复 和 消息广播</p>
<p><strong>1.协议过程</strong></p>
<p>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会 进入崩溃恢复模式，选举产生新的Leader</p>
<p>当选举产生了新的 Leader，同时集群中有过半的机器与该 Leader 服务器完成了状态同步（即数据同步）之后，Zab协议就会退出崩溃恢复模式，进入消息广播模式</p>
<p>这时，如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步 同步完成后，作为新的Follower一起参与到消息广播流程中</p>
<p><strong>2.协议状态切换</strong></p>
<p>当Leader出现崩溃退出或者机器重启，亦或是集群中不存在超过半数的服务器与Leader保存正常通信，Zab就会再一次进入崩溃恢复，发起新一轮Leader选举并实现数据同步 同步完成后又会进入消息广播模式，接收事务请求</p>
<p><strong>3.保证消息有序</strong></p>
<p>在整个消息广播中，Leader会将每一个事务请求转换成对应的 proposal 来进行广播，并且在广播 事务Proposal 之前，Leader服务器会首先为这个事务Proposal分配一个全局单递增的唯一ID，称之为事务ID（即zxid），由于Zab协议需要保证每一个消息的严格的顺序关系，因此必须将每一个proposal按照其zxid的先后顺序进行排序和处理</p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>一旦 Leader 服务器出现崩溃或者由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式</p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk30.png" alt="图片"></p>
<pre><code>具体过程如下：
1.为了保证 Leader 向 Learner 发送提案的有序，Leader 会为每一个 Learner 服务器准备一 个队列；
2.Leader 将那些没有被各个 Learner 同步的事务封装为 Proposal；
3.Leader 将这些 Proposal 逐条发给各个 Learner，并在每一个 Proposal 后都紧跟一个 COMMIT 消息，
表示该事务已经被提交，Learner 可以直接接收并执行 ；
4.Learner 接收来自于 Leader 的 Proposal，并将其更新到本地；
5.当 Learner 更新成功后，会向准 Leader 发送 ACK 信息；
</code></pre>
<p>Leader 服务器在收到来自 Learner 的 ACK 后就会将该 Learner 加入到真正可用的 Follower 列表或 Observer 列表 没有反馈 ACK，或反馈了但 Leader 没有收到的 Learner，Leader 不会将其加入到相应列表</p>
<h3 id="恢复模式的俩个原则"><a href="#恢复模式的俩个原则" class="headerlink" title="恢复模式的俩个原则"></a>恢复模式的俩个原则</h3><pre><code>1. 已被处理过的消息不能丢
1.当 Leader 收到超过半数 Follower 的 ACKs 后，就向各个 Follower 广播 COMMIT 消息
批准各个 Server 执行该写操作事务 当各个 Server 在接收到 Leader 的 COMMIT 消息后就会在本地执行该写操作
然后会向客户端响应写操作成功
2.如果在非全部 Follower 收到 COMMIT 消息之前 Leader 就挂了，这将导致一种后果部分 Server 已经执行了该事务
而部分 Server 尚未收到 COMMIT 消息，所以其并没有 执行该事务 当新的 Leader 被选举出
集群经过恢复模式后需要保证所有 Server 上都执行 了那些已经被部分 Server 执行过的事务

2. 被丢弃的消息不能再现
当在 Leader 新事务已经通过，其已经将该事务更新到了本地，但所有 Follower 还都没 有收到 COMMIT 之前
，Leader 宕机了（比前面叙述的宕机更早），此时，所有 Follower 根本 就不知道该 Proposal 的存在
当新的 Leader 选举出来，整个集群进入正常服务状态后，之 前挂了的 Leader 主机重新启动并注册成为了 Follower
若那个别人根本不知道的 Proposal 还保留在那个主机，那么其数据就会比其它主机多出了内容，导致整个系统状态的不一致 
所以，该 Proposa 应该被丢弃 类似这样应该被丢弃的事务，是不能再次出现在集群中的， 应该被清除
</code></pre>
<h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk31.png" alt="图片"></p>
<pre><code>如果集群中的 Learner 节点收到客户端的事务请求，那么这些 Learner 会将请求转发给 Leader 服务器 然后再执行如下的具体过程：
1.Leader 接收到事务请求后，为事务赋予一个全局唯一的 64 位自增 id，即 zxid，通过 zxid 的大小比较即可实现事务的有序性管理，然后将事务封装为一个 Proposal 
2.Leader 根据 Follower 列表获取到所有 Follower，然后再将 Proposal 通过这些 Follower 的 队列将提案发送给各个 Follower 
3.当Follower 接收到提案后，会先将提案的 zxid 与本地记录的事务日志中的最大的 zxid 进行比较 若当前提案的 zxid 大于最大 zxid，则将当前提案记录到本地事务日志中，并 向 Leader 返回一个 ACK （提问学员）
4.当Leader 接收到过半的 ACKs 后，Leader 就会向所有 Follower 的队列发送 COMMIT 消息，向所有 Observer 的队列发送 Proposal
5.当Follower 收到 COMMIT 消息后，就会将日志中的事务正式更新到本地 当 Observer 收到 Proposal 后，会直接将事务更新到本地
6.无论是 Follower 还是 Observer，在同步完成后都需要向 Leader 发送成功 ACK
</code></pre>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="三类角色"><a href="#三类角色" class="headerlink" title="三类角色"></a>三类角色</h4><pre><code>Leader：接收和处理客户端的读请求；zk 集群中事务请求的唯一处理者，并负责发起决 议和投票，然后将通过的事务请求在本地进行处理后，将处理结果同步给集群中的其它主机 
Follower：接收和处理客户端的读请求; 将事务请求转给 Leader；同步 Leader 中的数据；当 Leader 挂了，参与 Leader 的选举（具有选举权与被选举权）；
Observer：就是没有选举权与被选举权，且没有投票权的 Follower（临时工） 若 zk 集 群中的读压力很大，则需要增加 Observer，最好不要增加 Follower 因为增加 Follower 将会增大投票与统计选票的压力，降低写操作效率，及 Leader 选举的效率 
</code></pre>
<p>Learner &#x3D; Follower + Observer</p>
<p>QuorumServer &#x3D; Follower + Leader</p>
<p>在 ZAB 中有三个很重要的数据：</p>
<pre><code>zxid：是一个 64 位长度的 Long 类型 其中高 32 位表示 epoch，低 32 表示 xid 
epoch：每个 Leader 都会具有一个不同的 epoch，用于区分不同的时期（可以理解为朝代的年号）
xid：事务 id，是一个流水号，（每次朝代更替，即leader更换），从0开始递增 
每当选举产生一个新的 Leader ，就会从这个 Leader 服务器上取出本地事务日志中最大编号 Proposal 的 zxid，
并从 zxid 中解析得到对应的 epoch 编号，然后再对其加1，之后该编号就作为新的 epoch 值，并将低32位数字归零，由0开始重新生成zxid
</code></pre>
<h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><p>zk 集群中的每一台主机，在不同的阶段会处于不同的状态 每一台主机具有四种状态</p>
<pre><code>LOOKING：选举状态
FOLLOWING：Follower 的正常工作状态，从 Leader 同步数据的状态
OBSERVING：Observer 的正常工作状态，从 Leader 同步数据的状态
LEADING：Leader 的正常工作状态，Leader 广播数据更新的状态
</code></pre>
<p><strong>代码实现中，多了一种状态：Observing 状态这是 Zookeeper 引入 Observer 之后加入的，Observer 不参与选举，是只读节点，实际上跟 Zab 协议没有关系 这里为了阅读源码加上此概念</strong></p>
<h3 id="ZAB-的四个阶段"><a href="#ZAB-的四个阶段" class="headerlink" title="ZAB 的四个阶段"></a>ZAB 的四个阶段</h3><pre><code>myid:这是 zk 集群中服务器的唯一标识，称为 myid 例如，有三个 zk 服务器，那么编号分别 是 1,2,3 
逻辑时钟:逻辑时钟，Logicalclock，是一个整型数，该概念在选举时称为 logicalclock，而在选举结束后称为 epoch
即 epoch 与 logicalclock 是同一个值，在不同情况下的不同名称
</code></pre>
<h4 id="1-选举阶段"><a href="#1-选举阶段" class="headerlink" title="1.选举阶段"></a>1.选举阶段</h4><p>节点在一开始都处于选举节点，只要有一个节点得到超过半数节点的票数，它就可以当选准 Leader，只有到达第三个阶段（也就是同步阶段），这个准 Leader 才会成为真正的 Leader</p>
<p>Zookeeper 规定所有有效的投票都必须在同一个 轮次 中，每个服务器在开始新一轮投票时，都会对自己维护的 logicalClock 进行自增操作</p>
<p>每个服务器在广播自己的选票前，会将自己的投票箱（recvset）清空 该投票箱记录了所收到的选票</p>
<p>例如：Server2 投票给 Server3，Server3 投票给 Server1，则Server_1的投票箱为(2,3)、(3,1)、(1,1)（每个服务器都会默认给自己投票）</p>
<p>前一个数字表示投票者，后一个数字表示被选举者 票箱中只会记录每一个投票者的最后一次投票记录，</p>
<p>如果投票者更新自己的选票，则其他服务器收到该新选票后会在自己的票箱中更新该服务器的选票<br><strong>思考下：这里在实现中应该怎么实现呢？等我们分析源码时就可以看到，非常的巧妙</strong></p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk31.png" alt="图片"></p>
<p>这一阶段的目的就是为了选出一个准 Leader ，然后进入下一个阶段。</p>
<h4 id="2-发现阶段（Descovery）"><a href="#2-发现阶段（Descovery）" class="headerlink" title="2.发现阶段（Descovery）"></a>2.发现阶段（Descovery）</h4><p>在这个阶段，Followers 和上一轮选举出的准 Leader 进行通信，同步 Followers 最近接收的事务 Proposal 。</p>
<p>这个阶段的主要目的是发现当前大多数节点接收的最新 Proposal，并且准 Leader 生成新的 epoch ，让 Followers 接收，更新它们的 acceptedEpoch</p>
<h4 id="3-同步阶段（Synchronization"><a href="#3-同步阶段（Synchronization" class="headerlink" title="3.同步阶段（Synchronization)"></a>3.同步阶段（Synchronization)</h4><p>同步阶段主要是利用 Leader 前一阶段获得的最新 Proposal 历史，同步集群中所有的副本。</p>
<p>只有当 quorum（超过半数的节点） 都同步完成，准 Leader 才会成为真正的 Leader。Follower 只会接收 zxid 比自己 lastZxid 大的 Proposal</p>
<h4 id="4-广播阶段（Broadcast）"><a href="#4-广播阶段（Broadcast）" class="headerlink" title="4.广播阶段（Broadcast）"></a>4.广播阶段（Broadcast）</h4><p>到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 Leader 可以进行消息广播。同时，如果有新的节点加入</p>
<p>还需要对新节点进行同步。需要注意的是，Zab 提交事务并不像 2PC 一样需要全部 Follower 都 Ack，只需要得到 quorum（超过半数的节点）的Ack 就可以</p>
<h2 id="一、启动流程"><a href="#一、启动流程" class="headerlink" title="一、启动流程"></a>一、启动流程</h2><hr>
<p><strong>知识点：</strong></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1578206293&amp;ver=2077&amp;signature=gGEP8MjWBL9occ06T5B3SOnbolt3NmK9xhxK-zvL-B2tr5YH6II4vkUi4EFPhV-eAi4Kyw3veq0jF2EYjz9qAMZJv9xPquv8ojTML3uLAeUpNJ5mkXirK-zg6JAH9onD&amp;new=1">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1578206293&amp;ver=2077&amp;signature=gGEP8MjWBL9occ06T5B3SOnbolt3NmK9xhxK-zvL-B2tr5YH6II4vkUi4EFPhV-eAi4Kyw3veq0jF2EYjz9qAMZJv9xPquv8ojTML3uLAeUpNJ5mkXirK-zg6JAH9onD&amp;new=1</a></p>
<ol>
<li>工程结构介绍</li>
<li>启动流程宏观图</li>
<li>集群启动详细流程</li>
<li>netty 服务工作机制</li>
</ol>
<h3 id="1-工程结构介绍"><a href="#1-工程结构介绍" class="headerlink" title="1.工程结构介绍"></a>1.工程结构介绍</h3><p>项目地址:<a target="_blank" rel="noopener" href="https://github.com/apache/zookeeper.git">https://github.com/apache/zookeeper.git</a></p>
<p>分支tag ：3.5.5</p>
<ul>
<li>zookeeper-recipes: 示例源码</li>
<li>zookeeper-client: C语言客户端</li>
<li>zookeeper-server：主体源码</li>
</ul>
<h3 id="2-启动宏观流程图："><a href="#2-启动宏观流程图：" class="headerlink" title="2.启动宏观流程图："></a><strong>2.启动宏观流程图：</strong></h3><p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk20.png" alt="图片"></p>
<ul>
<li><input disabled type="checkbox"> 启动示例演示：</li>
</ul>
<p><strong>服务端：</strong>ZooKeeperServerMain</p>
<p><strong>客户端：</strong>ZooKeeperMain</p>
<h3 id="3-集群启动详细流程"><a href="#3-集群启动详细流程" class="headerlink" title="3.集群启动详细流程"></a>3.集群启动详细流程</h3><p>装载配置：</p>
<pre class="line-numbers language-none"><code class="language-none"># zookeeper 启动流程堆栈
 &gt;QuorumPeerMain#initializeAndRun &#x2F;&#x2F;启动工程 
   &gt;QuorumPeerConfig#parse &#x2F;&#x2F; 加载config 配置
    &gt;QuorumPeerConfig#parseProperties&#x2F;&#x2F; 解析config配置
 &gt;new DatadirCleanupManager &#x2F;&#x2F; 构造一个数据清器
  &gt;DatadirCleanupManager#start &#x2F;&#x2F; 启动定时任务 清除过期的快照<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>代码堆栈 ：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&gt;QuorumPeerMain#main  &#x2F;&#x2F;启动main方法
 &gt;QuorumPeerConfig#parse &#x2F;&#x2F; 加载zoo.cfg 文件
   &gt;QuorumPeerConfig#parseProperties &#x2F;&#x2F; 解析配置
 &gt;DatadirCleanupManager#start &#x2F;&#x2F; 启动定时任务清除日志
 &gt;QuorumPeerConfig#isDistributed &#x2F;&#x2F; 判断是否为集群模式
  &gt;ServerCnxnFactory#createFactory() &#x2F;&#x2F; 创建服务默认为NIO，推荐netty
 &#x2F;&#x2F;***创建 初始化集群管理器**&#x2F;
 &gt;QuorumPeerMain#getQuorumPeer
 &gt;QuorumPeer#setTxnFactory 
 &gt;new FileTxnSnapLog &#x2F;&#x2F; 数据文件管理器，用于检测快照与日志文件
   &#x2F;**  初始化数据库*&#x2F;
  &gt;new ZKDatabase 
    &gt;ZKDatabase#createDataTree &#x2F;&#x2F;创建数据树，所有的节点都会存储在这
 &#x2F;&#x2F; 启动集群：同时启动线程
  &gt; QuorumPeer#start &#x2F;&#x2F; 
    &gt; QuorumPeer#loadDataBase &#x2F;&#x2F; 从快照文件以及日志文件 加载节点并填充到dataTree中去
    &gt; QuorumPeer#startServerCnxnFactory &#x2F;&#x2F; 启动netty 或java nio 服务，对外开放2181 端口
    &gt; AdminServer#start&#x2F;&#x2F; 启动管理服务，netty http服务，默认端口是8080
    &gt; QuorumPeer#startLeaderElection &#x2F;&#x2F; 开始执行选举流程
    &gt; quorumPeer.join()  &#x2F;&#x2F; 防止主进程退出 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>流程说明:</strong></p>
<ol>
<li>main方法启动</li>
<li>加载zoo.cfg  配置文件</li>
<li>解析配置</li>
<li>创建服务工厂</li>
<li>创建集群管理线程<ol>
<li>设置数据库文件管理器</li>
<li>设置数据库</li>
<li>….设置设置</li>
</ol>
</li>
<li>start启动集群管理线程<ol>
<li>加载数据节点至内存</li>
<li>启动netty 服务，对客户端开放端口</li>
<li>启动管理员Http服务，默认8080端口</li>
<li>启动选举流程</li>
</ol>
</li>
<li>join 管理线程，防止main 进程退出</li>
</ol>
<h3 id="4-netty-服务启动流程："><a href="#4-netty-服务启动流程：" class="headerlink" title="4.netty 服务启动流程："></a>4.netty 服务启动流程：</h3><p>服务UML类图</p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk21.png" alt="图片"></p>
<p>设置netty启动参数</p>
<pre class="line-numbers language-none"><code class="language-none">-Dzookeeper.serverCnxnFactory&#x3D;org.apache.zookeeper.server.NettyServerCnxnFactory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>初始化：</strong></p>
<p>关键代码：</p>
<pre class="line-numbers language-none"><code class="language-none">#初始化管道流 
#channelHandler 是一个内部类是具体的消息处理器 
protected void initChannel(SocketChannel ch) throws Exception &#123;
    ChannelPipeline pipeline &#x3D; ch.pipeline();
    if (secure) &#123;
        initSSL(pipeline);
    &#125;
    pipeline.addLast(&quot;servercnxnfactory&quot;, channelHandler);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>channelHandler 类结构!</p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk22.png" alt="图片"></p>
<p>执行堆栈：</p>
<pre class="line-numbers language-none"><code class="language-none">NettyServerCnxnFactory#NettyServerCnxnFactory 	&#x2F;&#x2F; 初始化netty服务工厂
  &gt; NettyUtils.newNioOrEpollEventLoopGroup 	&#x2F;&#x2F; 创建IO线程组
  &gt; NettyUtils#newNioOrEpollEventLoopGroup() 	&#x2F;&#x2F; 创建工作线程组
  &gt;ServerBootstrap#childHandler(io.netty.channel.ChannelHandler) &#x2F;&#x2F; 添加管道流
&gt;NettyServerCnxnFactory#start 			&#x2F;&#x2F; 绑定端口，并启动netty服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>创建连接：</strong></p>
<p>每当有客户端新连接进来，就会进入该方法 创建 NettyServerCnxn对象 并添加至cnxns对例</p>
<p>执行堆栈</p>
<pre class="line-numbers language-none"><code class="language-none">CnxnChannelHandler#channelActive
 &gt;new NettyServerCnxn 		     &#x2F;&#x2F; 构建连接器
&gt;NettyServerCnxnFactory#addCnxn     &#x2F;&#x2F; 添加至连接器，并根据客户端IP进行分组
 &gt;ipMap.get(addr) &#x2F;&#x2F; 基于IP进行分组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>读取消息：</strong><br>执行堆栈</p>
<pre class="line-numbers language-none"><code class="language-none">CnxnChannelHandler#channelRead
&gt;NettyServerCnxn#processMessage &#x2F;&#x2F;  处理消息 
 &gt;NettyServerCnxn#receiveMessage &#x2F;&#x2F; 接收消息
  &gt;ZooKeeperServer#processPacket &#x2F;&#x2F;处理消息包
   &gt;org.apache.zookeeper.server.Request &#x2F;&#x2F; 封装request 对象
    &gt;org.apache.zookeeper.server.ZooKeeperServer#submitRequest &#x2F;&#x2F; 提交request  
     &gt;org.apache.zookeeper.server.RequestProcessor#processRequest &#x2F;&#x2F; 处理请求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二、快照与事务日志存储结构"><a href="#二、快照与事务日志存储结构" class="headerlink" title="二、快照与事务日志存储结构"></a>二、快照与事务日志存储结构</h2><hr>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要:"></a>概要:</h3><p>ZK中所有的数据都是存储在内存中，即zkDataBase中 但同时所有对ZK数据的变更都会记录到事物日志中，并且当写入到一定的次数就会进行一次快照的生成 已保证数据的备份 其后缀就是ZXID（唯一事物ID）</p>
<ul>
<li>事物日志：每次增删改，的记录日志都会保存在文件当中</li>
<li>快照日志：存储了在指定时间节点下的所有的数据</li>
</ul>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构:"></a><strong>存储结构:</strong></h3><p>zkDdataBase 是zk数据库基类，所有节点都会保存在该类当中，而对Zk进行任何的数据变更都会基于该类进行 zk数据的存储是通过DataTree 对象进行，其用了一个map 来进行存储</p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk23.png" alt="图片"></p>
<p>UML 类图：</p>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk24.png" alt="图片"></p>
<p>读取快照日志：</p>
<pre class="line-numbers language-none"><code class="language-none">org.apache.zookeeper.server.SnapshotFormatter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>读取事物日志：</p>
<pre class="line-numbers language-none"><code class="language-none">org.apache.zookeeper.server.LogFormatter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="快照相关配置："><a href="#快照相关配置：" class="headerlink" title="快照相关配置："></a>快照相关配置：</h3><table>
<thead>
<tr>
<th align="center">dataLogDir</th>
<th align="left">事物日志目录</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zookeeper.preAllocSize</td>
<td align="left">预先开辟磁盘空间，用于后续写入事务日志，默认64M</td>
</tr>
<tr>
<td align="center">zookeeper.snapCount</td>
<td align="left">每进行snapCount次事务日志输出后，触发一次快照，默认是100,000</td>
</tr>
<tr>
<td align="center">autopurge.snapRetainCount</td>
<td align="left">自动清除时 保留的快照数</td>
</tr>
<tr>
<td align="center">autopurge.purgeInterval</td>
<td align="left">清除时间间隔，小时为单位 -1 表示不自动清除</td>
</tr>
</tbody></table>
<h3 id="快照装载流程："><a href="#快照装载流程：" class="headerlink" title="快照装载流程："></a><strong>快照装载流程：</strong></h3><pre class="line-numbers language-none"><code class="language-none">&gt;ZooKeeperServer#loadData &#x2F;&#x2F; 加载数据
&gt;FileTxnSnapLog#restore &#x2F;&#x2F; 恢复数据
&gt;FileSnap#deserialize() &#x2F;&#x2F; 反序列化数据
&gt;FileSnap#findNValidSnapshots &#x2F;&#x2F; 查找有效的快照
  &gt;Util#sortDataDir &#x2F;&#x2F; 基于后缀排序文件
    &gt;persistence.Util#isValidSnapshot &#x2F;&#x2F; 验证是否有效快照文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/zhukovaskychina-github.io/tags/zookeeper/" rel="tag"># zookeeper</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/zhukovaskychina-github.io/2022/07/23/springcloud/eureka/" rel="prev" title="eureka 的源代码分析">
      <i class="fa fa-chevron-left"></i> eureka 的源代码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/zhukovaskychina-github.io/2022/07/23/springcloud/config/" rel="next" title="Spring Cloud Config 源代码分析">
      Spring Cloud Config 源代码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper%E6%A6%82%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">zookeeper概要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">zookeeper产生背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">zookeeper的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#znode-%E8%8A%82%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">znode 节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="nav-number">5.</span> <span class="nav-text">版本说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="nav-number">6.</span> <span class="nav-text">常规配置文件说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4"><span class="nav-number">7.</span> <span class="nav-text">客户端命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81Zookeeper%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D"><span class="nav-number"></span> <span class="nav-text">三、Zookeeper节点介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">知识点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">节点类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">节点属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E7%9B%91%E5%90%AC%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">节点的监听：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acl%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE"><span class="nav-number">5.</span> <span class="nav-text">acl权限设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AFAPI%E5%B8%B8%E8%A7%84%E5%BA%94%E7%94%A8-%E9%A1%B9%E7%9B%AE%E4%B8%BA-com-zkdesign-zookeeper%E7%9B%AE%E5%BD%95%E4%B8%8B"><span class="nav-number">6.</span> <span class="nav-text">一、客户端API常规应用 项目为 com.zkdesign.zookeeper目录下</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">6.1.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.</span> <span class="nav-text">初始连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E3%80%81%E6%9F%A5%E7%9C%8B%E8%8A%82%E7%82%B9"><span class="nav-number">6.3.</span> <span class="nav-text">创建、查看节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%8A%82%E7%82%B9"><span class="nav-number">6.4.</span> <span class="nav-text">查看节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%AD%90%E8%8A%82%E7%82%B9"><span class="nav-number">6.5.</span> <span class="nav-text">查看子节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E8%8A%82%E7%82%B9"><span class="nav-number">6.6.</span> <span class="nav-text">监听节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%AE%BE%E7%BD%AE%E8%8A%82%E7%82%B9ACL%E6%9D%83%E9%99%90"><span class="nav-number">6.7.</span> <span class="nav-text">4.设置节点ACL权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%AE%A2%E6%88%B7%E7%AB%AFZkClient"><span class="nav-number">6.8.</span> <span class="nav-text">5.第三方客户端ZkClient</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Zookeeper%E9%9B%86%E7%BE%A4"><span class="nav-number"></span> <span class="nav-text">二、Zookeeper集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-1"><span class="nav-number">1.</span> <span class="nav-text">知识点：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2-%E6%B3%A8%E6%84%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA"><span class="nav-number">1.1.</span> <span class="nav-text">1. 集群部署 注意数据库连接的端口号和通信的端口号不是一个</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">集群配置流程：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2%E8%AF%B4%E6%98%8E"><span class="nav-number">1.3.</span> <span class="nav-text">1. 集群角色说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">3.选举机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9B%9B%E5%AD%97%E8%BF%90%E7%BB%B4%E5%91%BD%E4%BB%A4"><span class="nav-number">3.</span> <span class="nav-text">5.四字运维命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-zk%E8%BF%9B%E9%98%B6%E2%80%93%E9%9B%86%E7%BE%A4%E2%80%93%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%A1%E7%90%86%E2%80%93%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E2%80%93%E5%88%86%E5%B8%83%E5%BC%8FJOB%E2%80%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number"></span> <span class="nav-text">1.zk进阶–集群–分布式管理–注册中心–分布式JOB–分布式锁*</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81-%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="nav-number"></span> <span class="nav-text">一、 分布式集群管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E7%9A%84%E9%9C%80%E6%B1%82"><span class="nav-number">1.</span> <span class="nav-text">分布式集群管理的需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">架构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">功能实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-number"></span> <span class="nav-text">二 、分布式注册中心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo-%E5%AF%B9zookeeper%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">Dubbo 对zookeeper的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo-Zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">Dubbo Zookeeper注册中心存储结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">3.</span> <span class="nav-text">流程说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="nav-number">4.</span> <span class="nav-text">示例演示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8FJOB"><span class="nav-number"></span> <span class="nav-text">三、分布式JOB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FJOB%E9%9C%80%E6%B1%82%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">分布式JOB需求：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">架构设计：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number"></span> <span class="nav-text">四、分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">锁的的基本概念：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">锁的获取：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%BE%8A%E7%BE%A4%E6%95%88%E5%BA%94%EF%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">关于羊群效应：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">示例演示：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZAB%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number"></span> <span class="nav-text">ZAB协议流程实现源码分析*</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFZAB%E5%8D%8F%E8%AE%AE"><span class="nav-number"></span> <span class="nav-text">什么是ZAB协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ZAB%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">ZAB协议原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZAB%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">ZAB核心原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZAB%E5%8D%8F%E8%AE%AE%E5%86%85%E5%AE%B9"><span class="nav-number">3.</span> <span class="nav-text">ZAB协议内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="nav-number">4.</span> <span class="nav-text">崩溃恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BF%A9%E4%B8%AA%E5%8E%9F%E5%88%99"><span class="nav-number">5.</span> <span class="nav-text">恢复模式的俩个原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD"><span class="nav-number">6.</span> <span class="nav-text">消息广播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%B1%BB%E8%A7%92%E8%89%B2"><span class="nav-number">7.1.</span> <span class="nav-text">三类角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">7.2.</span> <span class="nav-text">三种状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZAB-%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">8.</span> <span class="nav-text">ZAB 的四个阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%80%89%E4%B8%BE%E9%98%B6%E6%AE%B5"><span class="nav-number">8.1.</span> <span class="nav-text">1.选举阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%91%E7%8E%B0%E9%98%B6%E6%AE%B5%EF%BC%88Descovery%EF%BC%89"><span class="nav-number">8.2.</span> <span class="nav-text">2.发现阶段（Descovery）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5%EF%BC%88Synchronization"><span class="nav-number">8.3.</span> <span class="nav-text">3.同步阶段（Synchronization)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%B9%BF%E6%92%AD%E9%98%B6%E6%AE%B5%EF%BC%88Broadcast%EF%BC%89"><span class="nav-number">8.4.</span> <span class="nav-text">4.广播阶段（Broadcast）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">一、启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">1.工程结构介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%90%AF%E5%8A%A8%E5%AE%8F%E8%A7%82%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">2.启动宏观流程图：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">3.集群启动详细流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-netty-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">4.netty 服务启动流程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%BF%AB%E7%85%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number"></span> <span class="nav-text">二、快照与事务日志存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">概要:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">存储结构:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">快照相关配置：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%A3%85%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">快照装载流程：</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhukovasky</p>
  <div class="site-description" itemprop="description">技术宅的世界</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zhukovaskychina-github.io/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhukovaskychina" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhukovaskychina" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhukovasky</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/zhukovaskychina-github.io/lib/anime.min.js"></script>
  <script src="/zhukovaskychina-github.io/lib/pjax/pjax.min.js"></script>
  <script src="/zhukovaskychina-github.io/lib/velocity/velocity.min.js"></script>
  <script src="/zhukovaskychina-github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/zhukovaskychina-github.io/js/utils.js"></script>

<script src="/zhukovaskychina-github.io/js/motion.js"></script>


<script src="/zhukovaskychina-github.io/js/schemes/pisces.js"></script>


<script src="/zhukovaskychina-github.io/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://zhukovaskychina.github.io/zhukovaskychina-github.io/2022/07/23/zookeeper/zkbase/',]
      });
      });
  </script>

    </div>
</body>
</html>
